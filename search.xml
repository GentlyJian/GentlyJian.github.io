<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于for的一系列</title>
    <url>/posts/988e810e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>遍历数组常用for循环 ES5遍历数组的方法有forEach,map,filter,some，every,reduce等<br> 使用forEach不能使用break和return跳出循环</p>
<p>es5的forEach方法其实性能比for循环还要弱，使用for循环可以将长度用遍历存起来，可以优化性能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.length);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myArray = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>];</span><br><span class="line">myArray.name = <span class="string">"数组"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>,len = myArray.length; j &lt; len; j++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myArray[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="for-in"><a href="#for-in" class="headerlink" title="for...in"></a>for...in</h5><p>使用for in 遍历数组的毛病</p>
<p>1.index是字符串<br>2.遍历顺序可能不是数组的内部顺序<br>3.会遍历数组的可枚举对象包括原型，例如上面的method和name<br>所以for in 不适合遍历数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index,myArray[index])</span><br><span class="line"><span class="comment">//   0 a</span></span><br><span class="line"><span class="comment">//   1 b</span></span><br><span class="line"><span class="comment">//   2 c</span></span><br><span class="line"><span class="comment">//   3 d</span></span><br><span class="line"><span class="comment">//   name 数组</span></span><br><span class="line"><span class="comment">//   method function() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.length)</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="for-of"><a href="#for-of" class="headerlink" title="for...of"></a>for...of</h5><p>使用for of 遍历的是数组的值而 for in 遍历的是数组的键名<br>for of遍历只会遍历数组自身的值，而不会去遍历原型和其他属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><h5 id="1-使用for-in遍历对象"><a href="#1-使用for-in遍历对象" class="headerlink" title="1.使用for in遍历对象"></a>1.使用for in遍历对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">  a: <span class="string">"apple"</span>,</span><br><span class="line">  b: <span class="string">"banane"</span>,</span><br><span class="line">  c: <span class="string">"cherry"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> myObj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i,myObj[i])</span><br><span class="line"><span class="comment">// 会遍历到原型上的方法和属性</span></span><br><span class="line"><span class="comment">//   a apple</span></span><br><span class="line"><span class="comment">//   b banane</span></span><br><span class="line"><span class="comment">//   c cherry</span></span><br><span class="line"><span class="comment">//   method function() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(this)</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不想遍历原型上的方法和属性可以使用hasOwnPropery<br>hasOwnPropery可以判断某属性是否是对象的实例属性，从而过滤掉原型上的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> myObj) &#123;</span><br><span class="line">  <span class="keyword">if</span>(myObj.hasOwnProperty(i)) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i, myObj[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只获取自身属性</span></span><br><span class="line"><span class="comment">//   a apple</span></span><br><span class="line"><span class="comment">//   b banane</span></span><br><span class="line"><span class="comment">//   c cherry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="for-of-1"><a href="#for-of-1" class="headerlink" title="for...of"></a>for...of</h5><p>也可以使用for of 搭配Object.keys 来遍历对象 返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).<br>相关的Object属性还有<br>Object.getOwnPropertyNames(obj) 返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性).<br>使用Reflect.ownKeys(obj)遍历 返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举.  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, myObj[key])</span><br><span class="line">  <span class="comment">// 不包含原型属性</span></span><br><span class="line"><span class="comment">//   a apple</span></span><br><span class="line"><span class="comment">//   b banane</span></span><br><span class="line"><span class="comment">//   c cherry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实在想用 for of遍历对象，可以给该对象添加Symbol.iterator迭代器接口<br>接口自己实现<br>for of循环会先调用集合的Symbol.iterator方法，然后返回一个新的迭代器对象，<br>迭代器对象可以是任意具有next方法的对象，迭代器对象会重复调用这个方法<br>每循环一次调用一次<br>迭代器对象可以是任意具有next方法的对象，迭代器对象会重复调用这个方法var<br>使用Genertaor 自带next()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.a;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.b;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实现一个简单的迭代器</span></span><br><span class="line">myObj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(self);</span><br><span class="line">  <span class="keyword">const</span> len = keys.length;</span><br><span class="line">  <span class="keyword">let</span> pointer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line"> next() &#123;</span><br><span class="line">   <span class="keyword">const</span> done = pointer &gt;= len;</span><br><span class="line">   <span class="keyword">const</span> value = !done ? self[keys[pointer++]]: <span class="literal">undefined</span>;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     done,</span><br><span class="line">     value</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> myObj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用for of 遍历Map对象 顺便回顾一下Map对象的基本使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">"a"</span>, <span class="string">"apple"</span>],</span><br><span class="line">  [<span class="string">"b"</span>, <span class="string">"banane"</span>],</span><br><span class="line">  [<span class="string">"c"</span>, <span class="string">"cherry"</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 给Map对象添加属性</span></span><br><span class="line"><span class="built_in">console</span>.log(myMap.set(<span class="string">'d'</span>, <span class="string">'durian'</span>)) <span class="comment">// 返回是添加之后的Map</span></span><br><span class="line"><span class="comment">// 判断key是否存在 返回值 是否存在</span></span><br><span class="line">myMap.has(<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'myMap.has(\'a\'): '</span>, myMap.has(<span class="string">'a'</span>));</span><br><span class="line"><span class="comment">// myMap.delete('a') // 删除属性 返回值 是否删除成功</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'myMap.delete(\'a\'): '</span>, myMap.delete(<span class="string">'a'</span>));</span><br><span class="line"><span class="comment">// myMap.get('d') // 获取属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'myMap.get(\'d\') : '</span>, myMap.get(<span class="string">'d'</span>) );</span><br><span class="line">使用数组结构 <span class="built_in">Map</span>的item</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, val] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>for of 使用于遍历数组/数组对象[{},{}]/字符串/map/set等有迭代器对象的集合<br>但不能遍历对象，应为对象没有迭代器对象,它可以正确的相应break、continue、return语句<br>es5的forEach方法其实性能比for循环还要弱，使用for循环可以将长度用遍历存起来，可以优化性能</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/zjx304/p/10687017.html" target="_blank" rel="noopener">for in 和for of的区别</a><br><a href="https://blog.csdn.net/kuangshp128/article/details/85342343" target="_blank" rel="noopener">ES6可迭代对象与迭代器的理解</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝与深拷贝</title>
    <url>/posts/2ba55f9f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="1-使用Object-assign将原对象的值分配给一个新对象"><a href="#1-使用Object-assign将原对象的值分配给一个新对象" class="headerlink" title="1.使用Object.assign将原对象的值分配给一个新对象"></a>1.使用Object.assign将原对象的值分配给一个新对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	name: <span class="string">'zzj'</span></span><br><span class="line">	age: <span class="string">'22'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要在Object.assign 重新定义一个&#123;&#125; 然后将obj复制到&#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> objCp = <span class="built_in">Object</span>.assign(&#123;&#125;,obj)</span><br><span class="line"><span class="comment">// 修改objCp 的属性 不会影响原来的对象</span></span><br><span class="line">objCp.age = <span class="string">'23'</span></span><br><span class="line"><span class="built_in">console</span>.log(objCp, obj) <span class="comment">// &#123; name: 'zzj', age: '23' &#125; &#123; name: 'zzj', age: '22' &#125;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="2-使用ES6的扩展运算符"><a href="#2-使用ES6的扩展运算符" class="headerlink" title="2.使用ES6的扩展运算符"></a>2.使用ES6的扩展运算符</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zzj'</span>,</span><br><span class="line">  age: <span class="string">'22'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objCp = &#123;...obj&#125;</span><br><span class="line">objCp.age = <span class="string">'23'</span></span><br><span class="line"><span class="built_in">console</span>.log(objCp, obj) <span class="comment">// 效果同上</span></span><br></pre></td></tr></table></figure>

<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><h5 id="1-使用使用Json-parse-Json-stringfy-缺点：不能拷贝源对象中-undefined-值和-方法"><a href="#1-使用使用Json-parse-Json-stringfy-缺点：不能拷贝源对象中-undefined-值和-方法" class="headerlink" title="1.使用使用Json.parse(Json.stringfy()) 缺点：不能拷贝源对象中 undefined 值和 方法"></a>1.使用使用Json.parse(Json.stringfy()) 缺点：不能拷贝源对象中 undefined 值和 方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zzj'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  girlFriend: <span class="literal">undefined</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能拷贝方法 和 undefined</span></span><br><span class="line"><span class="keyword">let</span> objCp = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">objCp.name = <span class="string">'sjj'</span></span><br><span class="line">objCp.age = <span class="number">23</span></span><br><span class="line"><span class="built_in">console</span>.log(objCp, obj)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">'sjj'</span>, <span class="attr">age</span>: <span class="number">23</span> &#125; &#123; <span class="attr">name</span>: <span class="string">'zzj'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  girlFriend: <span class="literal">undefined</span>,</span><br><span class="line">  getName: [<span class="built_in">Function</span>: getName] &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-编写一个深拷贝函数"><a href="#2-编写一个深拷贝函数" class="headerlink" title="2.编写一个深拷贝函数"></a>2.编写一个深拷贝函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写一个函数</span></span><br><span class="line"><span class="comment">// 1. 判断传入的值是否是 对象 如果是进行拷贝，否则直接返回</span></span><br><span class="line"><span class="comment">// 2. 判断传入的值 是对象还是数组 给该值初始化&#123;&#125;或者[]</span></span><br><span class="line"><span class="comment">// 3.进行递归</span></span><br><span class="line"><span class="comment">// 深拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCp</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"> 	<span class="comment">// 判断是不是&#123;&#125;或者Array</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">'object'</span> &amp;&amp; data) &#123;</span><br><span class="line">    <span class="comment">// 判断该值是对象还是数组</span></span><br><span class="line">    <span class="keyword">let</span> val = <span class="keyword">typeof</span> data.length === <span class="string">'number'</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="comment">// 进行递归，对子项进行判断</span></span><br><span class="line">      val[item] = deepCp(data[item])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zzj'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  girlFriend: <span class="literal">undefined</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objCp = deepCp(obj)</span><br><span class="line">objCp.name = <span class="string">'sjj'</span></span><br><span class="line">objCp.age = <span class="number">23</span></span><br><span class="line"><span class="built_in">console</span>.log(objCp, obj)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">'sjj'</span>, <span class="attr">age</span>: <span class="number">23</span> &#125; &#123; <span class="attr">name</span>: <span class="string">'zzj'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  girlFriend: <span class="literal">undefined</span>,</span><br><span class="line">  getName: [<span class="built_in">Function</span>: getName] &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title>2019回顾</title>
    <url>/posts/5517bb68/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>&emsp;&emsp;天气逐渐变冷，2020 年也越来越近，今晚吹着冷风回来，头脑也比以往冷静了许多，趁着 2019 年末，新年到来之前给自己这一年做一个总结回顾吧。 </p>
<hr>
<p>&emsp;&emsp;这一年是蜕变的一年。虽然之前在WDJA实习，但公司给我的任务其实是很轻松的而且难度不高，于是我带着这种惯性回到了学校，在学校修炼了一下下。之后从学校毕业，我又来到了JA，但这次却和我实习干的活不一样。我被带到了广州分公司，在这里使用一种 dojo 的前端框架，顶着薄弱的前端基础在广州撑了两个星期，最后以基础太差（在加上那前端的负责人根本不想教新人，框架路径也就让自己看一遍）被遣回。回到武汉洋哥给了一个前后端的任务，虽然在洋哥的帮助下勉强完成工作，并让我后面跟着TXY一起做二次开发，虽然和TXY一起做二次开发会很轻松，但那并不是我想要的，我想要提升自己，所以我以自己需要培训为理由辞职了，洋哥听到我的决定后很高兴的同意了。。 </p>
<hr>
<p>&emsp;&emsp;我感觉我一直是一个很焦虑的人，特别是遇到自己预料之外的事情，我会做最坏的打算去应对，于是我搬离了武大园，和室长一起合租了一段时间，这这段时间我看着视频学习前端知识，最后又来到了武大园的ZZHT。在这里开启了我前端第一段路，同时也认识到了很多优秀的人，很感谢我的指导人YM耐心的指导我，还有同事 wl 和 whz。虽然只在这里待了 3 个月不到，但是在这里的收获还是挺多的，我学习到了 react 和很多处理问题的逻辑。最后由于内心的那份躁动和对当前工资的不满，我毅然辞职。</p>
<hr>
<p>&emsp;&emsp;辞职之后的第二个星期我收到了 LM 的邀请，来到了长沙。在这里呆了一个星期，也闹出了一个难忘的笑话，后面省略1w字</p>
<hr>
<p>&emsp;&emsp;从长沙回来，我便收到YP的面试邀请，最后顺利入职，如果说之前我都是一个带着学生的态度，那么这次便已经适应了毕业后的生活了。毕业如果还把自己当作学生，那么就一直会有一种依赖一种弱者的心里，毕业之后的目标是啥，找一个女朋友？找一份舒适的工作？都不是，毕业后我的目标是搞钱，有了钱就有了动力，有了钱也少了抱怨，有了钱俗一点也无所谓。</p>
]]></content>
      <categories>
        <category>daily</category>
        <category>2019</category>
      </categories>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>辞职感悟</title>
    <url>/posts/7997947e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;在zzht工作了三个月，好不容易熬到了转正但是我却不想加入这个大家庭。这里的小伙伴的确很好，我在这里也学到了很多东西，但是这里的工作强度对于我来说确实有点大。每天工作到晚上九点多，双休都没有了，感觉一点都不自由。在提离职前，我也在想自己辞职的理由，是因为工资太低了还是因为自己太矫情了不能适应这份工作。但想想或许工资高的确会有可能让我继续留下来，但是这样的工作方式，迟早还是会走。之前项目经理还让我考虑一下，这几天我也的确在想是不是该辞职。但最后还是双休战胜了高一点的工资。在双休中可以在忙碌的工作中放松一下自己，而且工作中越到后面学习的新东西越少，而双休的时间却可以去了解当前行业的新趋势和新技术。而且身体健康才是工作的资本，也许现在的确有精力能熬夜，但是等到了30多岁，身体变差了，头发变少了或许就后悔了。所以拥有自己的时间比去拿那稍微高一点的工资我感觉是正确的。</p>
<hr>
<p>&emsp;&emsp;不过在和勇哥提出离职的时候，我也有点内疚，毕竟培养了我三个月，和同事关系也都挺好的，昨晚whz还叫我别走，可是就算现在不走那在以后肯定也会溜的，既然这样还是果断一点吧。这三个月还是非常感谢蒙兄和同事的帮助，  这里的同事亲切多了，遇到了问题都会尽自己所知道的去帮助你，还耐心的给你讲解原理。勇哥还和我讲了在公司中的发展，让我明白了在一个公司发展技术是保障，业务熟练是阶梯，对底层框架的了解是一把钥匙，能打开封装框架的大门。</p>
<hr>
<p>&emsp;&emsp;在这三个月的工作中，我也收获到了很多专业知识，和很多开发的技巧。从一开始做一个功能不知如何下手，到慢慢熟悉框架的基本路径，功能写不出来就看别人的代码，最后复制别人可以用到的代码加上自己的逻辑判断完成一个功能。虽然感觉还是不去独立写出一个项目，但是至少自己有了一套开发功能的框架印象，在进入公司之前熟悉公司框架的使用还是得放在习巩固知识之前,中间有一段时间在看wl的代码，发现他的代码封装的非常好，用到了面向对象的思想，将一些函数封装成通用的方法，然后通过配置文件去获取对应的配置从而实现对应的功能，这个对我影响真的很大。不过我也仿照他的代码去写，却发现并没像自己看的那样简单，结果一个简单的方法，却被我弄成了山路十八弯。看来刚开始还是得先把基础的业务逻辑写出来，之后再去慢慢的优化封装。虽然最后竹篮打水但是却也提升了我看源码的能力。在编写功能过程中总会遇到许多问题，如果什么也不去看就去猜错误这真的是偷懒，我之前也是遇到问题，也没有很卖力的去调试错误，就去问wl，结果他一步一步的按着错误出现的位置，去分析，最后看着他的分析发现也不难自己也能做到，这样的场景挺尴尬的。以后还是尽力去调试出现的错误，而不是去猜所谓的错误。</p>
<hr>
<p>&emsp;&emsp;既然走上了程序员这条路，那么保持学习的动力是必不可少的，我辞职的确很大一部分是为了换取健康的生活方式，但如果连生活都过不下去，那健康也只是徒增烦恼。所以在后面工作日的时间里还是以工作学习为主，运动和休闲只是作为调试的一部分，毕竟工作能换来饭菜，而运动和休闲只能当作菜里的作料。</p>
<hr>
<p>&emsp;&emsp;以我现在的状况，我也不知道什么时候能找到新的工作，毕竟自己有前科了，但是对自己的要求还是不能低，这家公司就是鲜活的例子，改拿6000就不能放低要求去拿5000，不想出差就不能逞强去适应。找工作毕竟也是一份一大半靠实力和一小半靠运气的事，不能太急，记得上回看B站的一个UP主说找工作不能急，越急工资越低。在这过程中也许会慢慢对自己失去信心，但是这是可以弥补的，既然没找到那就继续学习吧。说到学习，经历从打算从事后端到裸辞跳到前端的我来说，应该没有什么难的了，毕竟两个星期的时间里我就掌握了ES6和React大部分知识。去学习新的知识先去看官方文档，文档看的吃力那就去找对应的视频。不过还是得以面试的要求为主，毕竟知识总不可能一次性全部掌握，可以后面在工作中休息中去学习，但是面试要求的技术就我目前的状况还是得去应付一下，后面以面试中的要求和面试题去针对的训练吧。</p>
<hr>
<p>&emsp;&emsp; 这次又和三个月之前一样了，工作中压力肯定是难免的，是痛苦的，但是解决问题后也会收获到莫名的喜悦，所以以后得享受这痛并快乐着的过程，而不是一遇到问题就妄自菲薄觉得自己能力不行，不适合这份工作，得辞职回去学习一段时间。这只是逃避的方式，发现自己也很容易去逃避问题，解决问题的确逃避是最容易的但是也是最没用的，没到万不得已还是尽量不要有这想法，在写功能时我一开始也是总是妄自菲薄，但是在一步一步看别人代码，不懂就去问熟悉的人，最后加上自己勇敢的去尝试去写，就算写的难看了，但是功能能做出来了也提升了不少。所以以后能解决的就努力去尝试，做一件事也要有始有终，抱着把它做好的心态去干，也不知道什么时候自己变得那么浮躁，甚至说话都不愿意带着思考去说，认为这样子很累。但是人既然活着就离不开打交道，你不长个心眼，那么就会多吃亏，亏吃多了不见得就是福，还有可能是真的啥。</p>
<hr>
<p>&emsp;&emsp; 最后既然自己选择了，那就没有什么后悔的，人生不就是一个充满选择的过程么，有失去就有新的收获，就看自己是用什么态度去面对了。加油，这是一个起点，但不是原来的起点，而是一条新-道路的起点！！！</p>
]]></content>
      <categories>
        <category>daily</category>
        <category>2019</category>
      </categories>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>重回科技园</title>
    <url>/posts/ad0b1c4e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>&emsp;&emsp;兜兜转转我又回到了wd科技园，哈哈和这里还真有一股虐缘，逃也逃不掉。或许自己当初选择了在广东入职估计生活就会变成另一番模样吧。这样一想突然发现生活还真是有趣，到处充满着选择，如果不想去闯荡那么以后的生活就会变成你熟悉的样子，如果选择了自己没有很大把握的那一条路，那么生活就会给你很多新鲜的东西，即使没有走通那条路，那一路的新鲜事物也会是不错的宝藏。平平淡淡也好，刺激新鲜也好，自己喜欢是才是最好的。</p>
<hr>
<p>&emsp;&emsp;想起昨天和货拉拉司机的对话，感觉收获还不少。他说武汉在他们那年代比深圳好多了，结果深圳这一个农村现在发展的比武汉还好。这人的思想眼光还是很重要啊。就比如现在武汉的房子，武汉这房价在 15 年之前还是 5000-8000 左右，现在都已经翻了两倍，有些人在那时候就看到了这趋势便把家里的房子卖了到武汉买了房，那现在就好好赚了一笔。但是人生的选择也是有风险的，你们现在还年轻，20 多岁是好好打基础的时候，有些路多走走就算走错了那也还有精力调整，等到了 30 多岁有了家庭孩子，那你就没有多余的路去走了，走错了可能就会一直穷下去，走对了那肯定就会一直好下去。所以 20 多岁好好打打基础当然也别一位的只注重技术上的提升还要提升一下眼光，多走走路。等机会到了一下抓住，人生可能就只有那一次的机会让你好下去了。你们现在 20 多岁身体也行，认知能力也是最好的时候，现在苦一点，多学一点，那你现在的一年就抵得到以后三四十岁的 5 年，等到了 40 岁人生就开始走下坡路了云云。</p>
<hr>
<p>&emsp;&emsp;这货拉拉司机的一番话还真是人生的一剂良药，打的还挺及时的，到了目的地还帮我搬了一下行李，我也先把最重的都搬到门口，毕竟 57 岁快退休的人就算精神面貌很好，也还是不要做些活动量太大的事情。等东西搬的差不多，这附近却找不到一家商店买水，司机也说算了，这本来就是他的工作，和司机道谢后便告别了。这里突然想起了老爸，哎，老爸还在那修一下铁疙瘩，以后还是劝他早点回来歇息着吧。</p>
]]></content>
      <categories>
        <category>daily</category>
        <category>2019</category>
      </categories>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
</search>
